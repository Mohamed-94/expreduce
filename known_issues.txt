4*a*b*c*d*e*f + -7*a*b*c*g*e*f /. c1match_Integer*matcha__ + c2match_Integer*matcha__ -> (c1match+c2match)*matcha
will actually combine, even though the terms are not the same

A lot of the function-specific eval functions start by evaluating their inputs. This is not needed because Expression now handles this by default.

Need to implement SequenceHold

Make sure all ToString methods are used and that they assert the number of parameters before accessing them. Must provide boolean as to if the operation succeeded? This could make debugging cumbersome.

Adding Attribute definitions seems to drastically increase the amount of time it takes to run the test suites. My theory in this is because I often take backups of es.defined and restore them. Perhaps a delta based approach would be better. I need to read up on how contexts and scopes work.

The reason Table[a, 5] doesn't currently work is because of HoldAll. In mathematica, you can still put pattern matches in HoldAll expressions and they will evaluate. Figure out why this is.

Example:

In[6]:= foo[amatch_, bmatch_Integer] := bar[amatch, {i, 1, bmatch}]

In[7]:= foo[k, 5]

Out[7]= bar[k, {i, 1, 5}]

In[8]:= Attributes[bar] := {HoldAll}

In[9]:= foo[k, 5]

Out[9]= bar[k, {i, 1, 5}]

This makes me think that the results of pattern matches are replaced at the end, not set in es.Defined. Evidence:

In[11]:= Hold[test + 2]

Out[11]= Hold[test + 2]

In[12]:= Hold[test + 2] /. test -> bla

Out[12]= Hold[bla + 2]

This means that replacements can transcend holding expressions, but:

In[13]:= test = bla

Out[13]= bla

In[14]:= Hold[test + 2]

Out[14]= Hold[test + 2]

but definitions do not. So perhaps I should rewrite the Replace function to use replace internally with matched values rather than temporarily adding them to the es.Defined set. After this change, I might no longer need to do GetDefinedSnapshot or ClearPD. We'll see. Could be much faster as well.

Also, this is an issue with the evaluation:
> 100/2
In:  (100 * 2^-1)
Out: (100 * 2^-1)
> 1/2*100
In:  ((1 * 2^-1) * 100)
Out: (2^-1 * 100)
> 1/2*1/2
In:  (((1 * 2^-1) * 1) * 2^-1)
Out: 2
> 1/2*5/2
In:  (((1 * 2^-1) * 5) * 2^-1)
Out: 10
>

        // Pattern
	CasAssertSame(t, es, "True", "MatchQ[a + b, a + b + x___Plus]")
	CasAssertSame(t, es, "Hold[Plus[a,b,c]]", "fooPlus[Plus[a, b, c]]")

        // Simplify
	CasAssertSame(t, es, "a^(2-c)", "a^2/a^c")


        // Operator precedence
	assert.Equal(t, "10", EasyRun("2^-2*40", es))
	assert.Equal(t, "-10", EasyRun("2^-2*-40", es))

        // Table
	CasAssertSame(t, es, "{{{0, 0}, {0, 1}, {0, 2}, {0, 3}}, {{1, 0}, {1, 1}, {1, 2}, {1, 3}}, {{2, 0}, {2, 1}, {2, 2}, {2, 3}}}", "Table[{a, b}, {a, 0, 2}, {b, 0, 3}]")


	// Test replacement within Hold parts
	assert.Equal(t, "Hold[Length[{a, b, c}]]", EasyRun("{a, b, c} /. {n__} :> Hold[Length[{n}]]", es))
	assert.Equal(t, "Hold[Length[{a, b, c}]]", EasyRun("{a, b, c} /. {n__} -> Hold[Length[{n}]]", es))

	// Text Expand
			&SameTest{"Null", "f[n_, m_] := Sum[KroneckerDelta[m - Sum[r[i], {i, n}]] (Multinomial @@ Sequence@Array[r, n]) Product[x[i]^r[i], {i, n}], Evaluate@(Sequence @@ Table[{r[i], 0, m}, {i, 1, n}])]"},
			&SameTest{"x[1]^3 + 3 (x[1]^2)*x[2] + 3 x[1]*(x[2]^2) + x[2]^3", "f[2,3]"},
	//		&SameTest{"Null", "myexpand[(Plus[addends__])^(mmatch_Integer)] := Sum[KroneckerDelta[mmatch - Sum[r[i], {i, Length[{addends}]}]]*Multinomial @@ Sequence[Array[r, Length[{addends}]]]*Product[x[i]^r[i], {i, Length[{addends}]}], Evaluate[Sequence @@ Table[{r[i], 0, mmatch}, {i, 1, Length[{addends}]}]]]"},
	//		&SameTest{"x[1]^3 + 3 (x[1]^2)*x[2] + 3 x[1]*(x[2]^2) + x[2]^3", "myexpand[(y[1] + y[2])^3]"},

			//&TestComment{"Notice how rules are applies until no further rules apply. If we only used `ReplaceAll`, only the first step of simplification would occur:"},
			// Expreduce does not currently return the following:
			//&SameTest{"Log[a^b] + Log[b^(c^d)]", "Log[a^b*b^(c^d)] /. logRules"},

			// This test currently fails, probably due to Orderless pattern
			// matching issues.
			//&SameTest{"Log[a] + e (Log[b] + d Log[c])", "PowerExpand[Log[a (b c^d)^e]]"},
